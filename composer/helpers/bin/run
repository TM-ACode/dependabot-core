#!/usr/bin/env php
<?php

declare(strict_types=1);

namespace Dependabot\Composer;

require dirname(__DIR__) . '/vendor/autoload.php';

// Get details of the process to run from STDIN. It will have a `function`
// and an `args` method, as passed in by UpdateCheckers::Php
$request = json_decode(file_get_contents('php://stdin'), true);

// Increase the default memory limit the same way Composer does (but clearer)
if (function_exists('ini_set')) {
    $memoryInBytes = static function (string $value): int {
        $unit = strtolower(substr($value, -1, 1));
        $value = (int) $value;
        if ($unit == 'g') {
            $value *= (1024 * 1024 * 1024);
        } elseif ($unit == 'm') {
            $value *= (1024 * 1024);
        } elseif ($unit == 'k') {
            $value *= 1024;
        }

        return $value;
    };

    $memoryLimit = trim(ini_get('memory_limit'));
    // Increase memory_limit if it is lower than 1900MB
    if ($memoryLimit !== "" && $memoryInBytes($memoryLimit) < 1024 * 1024 * 1900) {
        @ini_set('memory_limit', '1900M');
    }

    // Set user defined memory limit
    if ($memoryLimit = getenv('COMPOSER_MEMORY_LIMIT')) {
        @ini_set('memory_limit', $memoryLimit);
    }
    unset($memoryInBytes, $memoryLimit);
}

date_default_timezone_set('Europe/London');

// This storage is freed on error (case of allowed memory exhausted)
$memory = str_repeat('*', 1024 * 1024);

function output(array $content): void {
    fwrite(STDOUT, json_encode($content));
}

register_shutdown_function(function (): void {
    global $memory;
    $memory = null;
    $error = error_get_last();
    if (null !== $error) {
        output(['error' => $error['message']]);
    }
});

try {
    switch ($request['function']) {
        case 'update':
            [$workingDirectory, $dependencyName, $dependencyVersion, $gitCredentials, $registryCredentials] = $request['args'];
            $updatedFiles = Helper::update($workingDirectory, $dependencyName, $gitCredentials, $registryCredentials);
            output(['result' => $updatedFiles]);
            error_clear_last();
            break;
        case 'get_latest_resolvable_version':
            $latestVersion = Helper::getLatestResolvableVersion(...$request['args']);
            output(['result' => $latestVersion]);
            error_clear_last();
            break;
        case 'get_content_hash':
            $content_hash = Helper::getContentHash(...$request['args']);
            output(['result' => $content_hash]);
            error_clear_last();
            break;
        default:
            output(['error' => "Invalid function {$request['function']}"]);
            exit(1);
    }
} catch (\Exception $e) {
    output(['error' => $e->getMessage()]);
    error_clear_last();
    exit(1);
}
